---
title: "Simulación de ítems con distribuciones no-normales y su efecto en el análisis factorial exploratorio mediante correlaciones teracóricas/policóricas"
authors:
  - name: Brian Norman Peña-Calero
    orcid: 0000-0002-1073-9306
    affiliation: Universidad Complutense de Madrid (UCM)
    email: 
    roles: 
      - Researcher
      - Analyst
    corresponding: true
date: last-modified
date-format: "DD MMMM, YYYY"
lang: es
lightbox: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

# Condiciones de simulacion

```{r}
library(tidyverse)
```

- Número de ítems: 
  + 1 Factor: 
    * 5 ítems: cargas superior a 0.60 y cargas entre 0.30 a 0.70
    * 8 ítems: cargas superior a 0.60 y cargas entre 0.30 a 0.70
  + 2 Factores: 5 ítems por factor
  
  
Para la definición de los umbrales se realizó una adaptación de lo sugerido en @yang2015:

- Umbrales simétricos:
  + 2 categorías: $\tau_1 = 0$
  + 5 categorías: $\tau_1 = -1.5$, $\tau_2 = -0.5$, $\tau_3 = 0.5$, $\tau_4 = 1.5$
- Umbrales asimétricos:
  + 2 categorías: $tau_1 = -1$
  + 5 categorías: $\tau_1 = 0$, $\tau_2 = -0.5$, $\tau_3 = -1.25$, $\tau_4 = -1.75$


```{r}
r_unif_seed <- function(n, min, max, seed = 123) {
  set.seed(seed)
  round(runif(n, min, max))
}


loading_sim <- function(n_items, type_loadings, seed = 123) {
  
  if (type_loadings == "high") {
    min_loading <-  0.6
    max_loading <- 0.9
  } else if (type_loadings == "mid") {
    min_loading <-  0.3
    max_loading <- 0.7
  }
  
  set.seed(seed)
  round(runif(n_items, min_loading, max_loading), 3)
}

threshold_sim <- function(n_items, type_threshold, n_cat, seed = 123) {
  set.seed(seed)
  
  # Definir los umbrales base según el tipo y número de categorías
  base_thresholds <- switch(
    type_threshold,
    "symetric" = if (n_cat == 2) c(0) else c(-1.5, -0.5, 0.5, 1.5),
    "asym" = if (n_cat == 2) c(-1) else c(0, -0.5, -1.25, -1.75),
    stop("Invalid type_threshold")
  )
  
  # Agregar ruido a los umbrales base para cada ítem
  thresholds_list <- replicate(n_items, {
    sapply(base_thresholds, function(threshold) round(threshold + runif(1, -0.05, 0.05), 3))
  }, simplify = FALSE)
  
  return(thresholds_list)
}
```


```{r}
sim_conditions <- expand_grid(
  n_size = c(200, 500, 1000),
  n_factor = 1,
  distribution = c("MVN", "Non-MVN"),
  n_items = c(5, 8),
  type_loadings = c("high", "mid"),
  n_cat = c(2, 5),
  type_threshold = c("symetric", "asym")
)

sim_conditions <- sim_conditions |> 
  mutate(
    # Crear un identificador único para las combinaciones relevantes
    combo_id = paste(n_items, type_loadings, sep = "_"),
    # Asignar una semilla única a cada combinación
    unique_seed = as.integer(factor(combo_id)) + 100  # Generar semillas únicas replicables
  ) |> 
  group_by(combo_id) |> 
  mutate(
    # Usar la semilla única para generar valores aleatorios
    seed_loadings = r_unif_seed(1, 1, 100, unique_seed)
  ) |> 
  ungroup() |> 
  select(-combo_id, -unique_seed)  # Eliminar columnas temporales

sim_conditions <- sim_conditions |> 
  rowwise() |> 
  mutate(
    pre_loadings = list(loading_sim(n_items, type_loadings, seed_loadings)),
    thresholds = list(threshold_sim(
      n_items = n_items, 
      type_threshold = type_threshold, 
      n_cat = n_cat
    ))
  ) |> 
  select(-seed_loadings) |> 
  ungroup()

sim_conditions <- expand_grid(sim_conditions, n_replic = 1:500) |> 
  relocate(n_replic, .after = type_threshold) 
```


# Simulación

```{r}
generate_items <- function(n_size, distribution, n_items, pre_loadings, thresholds, n_cat) {
  # Generar el factor latente (F1)
  if (distribution == "MVN") {
    F1 <- rnorm(n_size)
  } else if (distribution == "Non-MVN") {
    F1 <- detectnorm::rnonnorm(n_size, skew = 7, kurt = 20)
    F1 <- F1$dat
  } else {
    stop("Invalid distribution type")
  }
  
  # Inicializar listas para almacenar los ítems generados
  items <- vector("list", n_items)
  items_cat <- vector("list", n_items)
  
  # Generar cada ítem
  for (i in seq_len(n_items)) {
    # Generar ítem continuo
    loading <- pre_loadings[i]
    error_sd <- sqrt(1 - loading^2)
    items[[i]] <- loading * F1 + error_sd * rnorm(n_size)
    
    # Categorizar el ítem usando los umbrales
    thresholds_i <- thresholds[[i]]
    
    # Validar que los thresholds coincidan con n_cat
    if (length(thresholds_i) + 1 != n_cat) {
      stop(glue::glue("Mismatch: n_cat = {n_cat}, thresholds = {length(thresholds_i)}"))
    }
    
    items_cat[[i]] <- cut(
      items[[i]], 
      breaks = c(-Inf, thresholds_i, Inf), 
      labels = seq_len(n_cat),
      right = FALSE
    )
  }
  
  # Combinar en un data frame
  items_df <- as.data.frame(do.call(cbind, items))
  colnames(items_df) <- paste0("x", seq_len(n_items))
  
  items_cat_df <- as.data.frame(do.call(cbind, items_cat))
  colnames(items_cat_df) <- paste0("x", seq_len(n_items), "_cat")
  
  # Retornar ambos conjuntos de datos
  return(cbind(items_df, items_cat_df))
}
```

```{r}
library(multidplyr)
cluster <- new_cluster(parallel::detectCores())
cluster_copy(cluster, "generate_items")
```

```{r}
sim_items_data <-  sim_conditions |> 
  rowwise() |> 
  partition(cluster) %>%
  mutate(
    sim_data = list(
      generate_items(n_size, distribution, n_items, pre_loadings, thresholds, n_cat)
    )
  )

sim_items_data <- sim_items_data |> 
  collect()
```

```{r}
saveRDS(sim_items_data, file = "sim_items_data.RData")
```

